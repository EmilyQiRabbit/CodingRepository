> * Title：前端面经不完全总结：JS 篇
> * Author：[EmilyQiRabbit 🙋 旺财](https://github.com/EmilyQiRabbit)
> * Links:
>      * [HTML篇](https://github.com/EmilyQiRabbit/CodingRepository/blob/master/InterviewSummery/html.md)
>      * [CSS篇](https://github.com/EmilyQiRabbit/CodingRepository/blob/master/InterviewSummery/css.md)
>      * [JS篇](https://github.com/EmilyQiRabbit/CodingRepository/blob/master/InterviewSummery/js.md)
>      * [NetWork篇](https://github.com/EmilyQiRabbit/CodingRepository/blob/master/InterviewSummery/network.md)

#### 目录
(toc generated by [ghtoc](https://github.com/sk1418/ghtoc))
            - [目录](#目录)
- [排序算法](#排序算法)
    - [冒泡排序](#冒泡排序)
    - [选择排序](#选择排序)
    - [插入排序](#插入排序)
    - [归并排序](#归并排序)
    - [快速排序](#快速排序)
    - [堆排序](#堆排序)
    - [计数排序](#计数排序)
    - [桶排序](#桶排序)
- [动态规划](#动态规划)
    - [动态规划算法的两种形式](#动态规划算法的两种形式)
        - [自顶向下法](#自顶向下法)
        - [自底向上](#自底向上)
- [事件委托](#事件委托)
- [this的绑定规则](#this的绑定规则)
    - [默认绑定](#默认绑定)
    - [隐式绑定](#隐式绑定)
    - [显式绑定](#显式绑定)
    - [new绑定](#new绑定)
- [Async如何封装Generator](#Async如何封装Generator)
- [PWA](#PWA)
    - [Web在移动端面临的问题](#Web在移动端面临的问题)
    - [解决方案](#解决方案)
    - [Web App Manifest](#Web-App-Manifest)
    - [Service Worker](#Service-Worker)
    - [Push Notification](#Push-Notification)
    - [总结](#总结)
- [关系型数据库与非关系型数据库](#关系型数据库与非关系型数据库)
    - [关系型数据库](#关系型数据库)
    - [非关系型数据库](#非关系型数据库)
- [一个按需加载的解决方案](#一个按需加载的解决方案)
- [观察者模式](#观察者模式)
- [对象的解构赋值](#对象的解构赋值)

# 排序算法

又一个记了忘、忘了记的知识点...

[捂脸]忘了的，那 👉[戳这里吧](http://www.cnblogs.com/onepixel/articles/7674659.html)
这个教程有动图演示，炒鸡棒的哦🎉

## 冒泡排序

核心思路：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。

```javaScript
function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i < len; i++) {
        for (var j = 0; j < len - 1 - i; j++) {
            if (arr[j] > arr[j+1]) {        // 相邻元素两两对比
                var temp = arr[j+1];        // 元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}
```

## 选择排序

```javaScript
function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i < len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j < len; j++) {
            if (arr[j] < arr[minIndex]) {     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            }
        }
        temp = arr[i]; // 交换
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
} 
```

## 插入排序

它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

```js
function insertionSort(arr) {
    var len = arr.length;
    var preIndex, current;
    for (var i = 1; i < len; i++) {
        preIndex = i - 1;
        current = arr[i];
        while (preIndex >= 0 && arr[preIndex] > current) {
            arr[preIndex + 1] = arr[preIndex]; // 移位，为后续的插入预留位置
            preIndex--;
        }
        arr[preIndex + 1] = current;
    }
    return arr;
}
```

## 归并排序

归并排序 (MergeSort) 算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。

```js
function mergeSort(arr) {  // 采用自上而下的递归方法
    var len = arr.length;
    if (len < 2) {
        return arr;
    }
    var middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
}
 
function merge(left, right) {
    var result = [];
 
    while (left.length>0 && right.length>0) {
        if (left[0] <= right[0]) {
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }
 
    while (left.length)
        result.push(left.shift());
 
    while (right.length)
        result.push(right.shift());
 
    return result;
}
```

## 快速排序

快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

这个稍微有点复杂、不过也还好，多看两遍动图，结合代码看一看，就懂了～

```js
function quickSort(arr, left, right) {
    var len = arr.length,
        partitionIndex,
        left = typeof left != 'number' ? 0 : left,
        right = typeof right != 'number' ? len - 1 : right;
 
    if (left < right) {
        partitionIndex = partition(arr, left, right);
        quickSort(arr, left, partitionIndex-1);
        quickSort(arr, partitionIndex+1, right);
    }
    return arr;
}
 
function partition(arr, left ,right) {     // 分区操作
    var pivot = left,                      // 设定基准值（pivot）
        index = pivot + 1;
    for (var i = index; i <= right; i++) {
        if (arr[i] < arr[pivot]) {
            swap(arr, i, index);
            index++;
        }       
    }
    swap(arr, pivot, index - 1);
    return index-1;
}
 
function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

## 堆排序

堆排序（Heapsort）是指利用「堆」这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足：子结点的键值或索引总是小于（或者大于）它的父节点。

```js
var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量
 
function buildMaxHeap(arr) { // 建立大顶堆
    len = arr.length;
    for (var i = Math.floor(len/2); i >= 0; i--) { // Math.floor(len/2) -> 最后一个非叶子节点的位置
        heapify(arr, i);
    }
}
 
function heapify(arr, i) { // 堆调整 -> i 表示根节点位置
    var left = 2 * i + 1, // 左右子节点坐标
        right = 2 * i + 2,
        largest = i;
 
    if (left < len && arr[left] > arr[largest]) {
        largest = left;
    }
 
    if (right < len && arr[right] > arr[largest]) {
        largest = right;
    }
 
    if (largest != i) {
        swap(arr, i, largest);
        heapify(arr, largest); // 递归的继续调整
    }
}
 
function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
 
function heapSort(arr) {
    buildMaxHeap(arr);
 
    for (var i = arr.length - 1; i > 0; i--) {
        swap(arr, 0, i);
        len--;
        heapify(arr, 0);
    }
    return arr;
}
```

## 计数排序

计数排序 (CountingSort) 的「核心」在于：将输入的数据值转化为键存储在「额外开辟」的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的「数据必须是有确定范围的整数」。

```js
function countingSort(arr, maxValue) {
    var bucket = new Array(maxValue + 1), // 对于 bucket 来说，下标就是原始 arr 中的元素值
        sortedIndex = 0;
        arrLen = arr.length,
        bucketLen = maxValue + 1;
 
    for (var i = 0; i < arrLen; i++) {
        if (!bucket[arr[i]]) {
            bucket[arr[i]] = 0;
        }
        bucket[arr[i]]++;
    }
 
    for (var j = 0; j < bucketLen; j++) {
        while(bucket[j] > 0) {
            arr[sortedIndex++] = j;
            bucket[j]--;
        }
    }
 
    return arr;
}
```

**当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k))，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。**

## 桶排序

桶排序 (BucketSort) 是计数排序的升级版。它利用了函数的映射关系，**高效与否的关键就在于这个映射函数的确定**。
桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。

```js
function bucketSort(arr, bucketSize) {
    if (arr.length === 0) {
      return arr;
    }
 
    var i;
    var minValue = arr[0];
    var maxValue = arr[0];
    for (i = 1; i < arr.length; i++) {
      if (arr[i] < minValue) {
          minValue = arr[i];                // 输入数据的最小值
      } else if (arr[i] > maxValue) {
          maxValue = arr[i];                // 输入数据的最大值
      }
    }
 
    // 桶的初始化
    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5
    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;
    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;  
    var buckets = new Array(bucketCount);
    for (i = 0; i < buckets.length; i++) {
        buckets[i] = [];
    }
 
    // 利用映射函数将数据分配到各个桶中
    for (i = 0; i < arr.length; i++) {
        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);
    }
 
    arr.length = 0;
    for (i = 0; i < buckets.length; i++) {
        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序
        for (var j = 0; j < buckets[i].length; j++) {
            arr.push(buckets[i][j]);                     
        }
    }
 
    return arr;
}
```

# 动态规划

动态规划算法的核心就是：**记住已经解决过的子问题的解**。

这里有个很通俗的例子：

> A1 : 1+1+1+1+1+1+1+1 = ?
> A1 : 等式的值是多少？
> B2 : *计算* 8！
> A1 : 在上面等式的左边写上 "1+"
> A1 : 此时等式的值为多少？
> B2 : *quickly* 9！
> A1 : 你怎么这么快就知道答案了？
> B2 : 只要在8的基础上加1就行了。
> 所以你不用重新计算，因为你记住了第一个等式的值为8！动态规划算法也可以说是：'记住求过的解来节省时间'。

## 动态规划算法的两种形式

动态规划算法的核心是**记住已经求过的解**，那么，记住求解的方式有两种：**自顶向下**和**自底向上**。 

为了说明这两种方法，举一个最简单的例子：求斐波拉契数列Fibonacci。

### 自顶向下法

自顶向下法即：**设立备忘录Memo**。

```java
public static int Fibonacci(int n)
{
  if(n<=0)
    return n;
  int []Memo=new int[n+1];        
  for(int i=0;i<=n;i++)
    Memo[i]=-1;
  return fib(n, Memo);
}

public static int fib(int n,int []Memo)
{
  if(Memo[n]!=-1)
    return Memo[n];
    // 如果已经求出了 fib(n) 的值直接返回，否则将求出的值保存在 Memo 备忘录中。               
  if(n<=2)
    Memo[n]=1;
  else Memo[n]=fib(n-1,Memo)+fib(n-2,Memo);
  return Memo[n];
}
```

### 自底向上

自顶向下法还是利用了递归。而自底向上的思路则是：不管怎样，计算 fib(6) 的时候最后还是要计算出fib(1)，fib(2)，fib(3)...那么何不先计算出fib(1)，fib(2)，fib(3)...呢？这也就是动态规划的核心 -- **先计算子问题，再由子问题计算父问题**。

```java
public static int fib(int n)
{
  if(n<=0)
    return n;
  int []Memo=new int[n+1];
  Memo[0]=0;
  Memo[1]=1;
  for(int i=2;i<=n;i++)
  {
    Memo[i]=Memo[i-1]+Memo[i-2];
  }       
  return Memo[n];
}
```

小节内容选自 [CSDN 博客](https://blog.csdn.net/u013309870/article/details/75193592)。原文比较深入，上文仅是最简单的概念说明。

# 事件委托

事件委托就是利用冒泡的原理，把事件的监听加到父级元素元素上，触发执行效果。

例如：

```js
var btn = document.getElementById("btn");
document.onclick = function(event){
  event = event || window.event;
  var target = event.target || event.srcElement;
  if(target === btn){
    alert(btn.value);
    ...
  }
}
```

为什么选用事件委托：

1. 事件委托可以显著的提高事件的处理速度，减少内存的占用

2. 动态的添加 DOM 元素，不需要因为元素的改动而修改事件绑定。

# this的绑定规则

**每个函数的 this 是在调用时被绑定的，完全取决于函数的调用位置。寻找 this，就是寻找调用位置，也就是寻找“函数被调用的位置”。**

## 默认绑定

默认绑定时，this 指向全局对象。

```js
function foo() { 
    console.log( this.a );
}
var a = 2; 
foo(); // 2
```

分析一下代码能发现：在代码中，foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。

如果使用严格模式(strict mode)，那么全局对象将无法使用默认绑定，因此 this 会绑定到 undefined。

## 隐式绑定

```js
function foo() { 
    console.log( this.a );
}
var obj = { 
    a: 2,
    foo: foo 
};
obj.foo(); // 2
```

首先需要注意的是 `foo()` 的声明方式，及其之后是如何被当作引用属性添加到 obj 中的。 
但是无论是直接在 obj 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于 obj 对象。

然而，调用位置会使用 obj 上下文来引用函数，因此你可以说**函数被调用时** obj 对象“拥有”或者“包含”它。

无论你如何称呼这个模式，当 `foo()` 被调用时，它的落脚点确实指向 obj 对象。当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调用 `foo()` 时 this 被绑定到 obj，因此 `this.a` 和 `obj.a` 是一样的。

⚠️需要注意：**隐式丢失**

```js
function foo() { 
    console.log( this.a );
}
var obj = { 
    a: 2,
    foo: foo 
};
var bar = obj.foo; // 函数别名!
var a = "oops, global"; // a是全局对象的属性 
bar(); // "oops, global"
```

虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 bar() 其实是一个**不带任何修饰的函数调用**，因此应用了默认绑定。

一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时:

```js
function foo() { 
  console.log( this.a );
}
function doFoo(fn) {
  // fn其实引用的是foo 
  fn(); // <-- 调用位置!
}
var obj = { 
  a: 2,
  foo: foo 
};
var a = "oops, global"; // a是全局对象的属性 
doFoo( obj.foo ); // "oops, global"
```

参数传递其实就是一种**隐式赋值**，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样。

## 显式绑定

方法：使用 `call(..)` 和 `apply(..)`。

这两个方法是如何工作的呢？它们的第一个参数是一个对象，它们会把这个对象绑定到 this，接着在调用函数时指定这个 this。因为你可以直接指定 this 的绑定对象，因此我们称之为显式绑定。

```js
function foo() { 
    console.log( this.a );
}
var obj = { 
    a:2
};
foo.call( obj ); // 2 -> 相当于 foo 函数中的所有 this 都指的 obj
```

可惜，显式绑定仍然无法解决我们之前提出的丢失绑定问题。

但是显式绑定的一个变种可以解决这个问题，那就是硬绑定：

```js
function foo() { 
    console.log( this.a );
}
var obj = { 
    a:2
};
var bar = function() { 
    foo.call( obj );
};
bar(); // 2
setTimeout( bar, 100 ); // 2
// 硬绑定的 bar 不可能再修改它的 this 
bar.call( window ); // 2
```

此时，无论之后如何调用函数 bar，它总会手动在 obj 上调用 foo。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。

由于硬绑定是一种非常常用的模式，所以在 ES5 中提供了内置的方法 Function.prototype.bind：

```js
function foo(something) { 
    console.log( this.a, something ); 
    return this.a + something;
}
var obj = { 
    a:2
};
var bar = foo.bind( obj );
var b = bar( 3 ); // 2 3 
console.log( b ); // 5
```

## new绑定

JavaScript 的 new 操作符，使用方法看起来和那些面向类的语言一样。所以绝大多数开发者都认为 JavaScript 中 new 的机制也和那些语言一样。然而，JavaScript 中 new 的机制实际上和面向类的语言**完全不同**。

首先我们重新定义一下 JavaScript 中的“构造函数”。在 JavaScript 中，构造函数只是一些使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能说是一种特殊的函数类型，**它们只是被 new 操作符调用的普通函数而已**。

这里有一个重要但是非常细微的区别：**实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”**。

使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。

1. 创建(或者说构造)一个全新的对象。
2. 这个新对象会被执行[[原型]]连接。
3. 这个新对象会绑定到函数调用的 this。
4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。

```js
function foo(a) { 
    this.a = a;
}
var bar = new foo(2); 
console.log( bar.a ); // 2
```

使用 new 来调用 `foo(..)` 时，我们会构造一个新对象并把它绑定到 `foo(..)` 调用中的 this 上。new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。

# Async 如何封装 Generator

async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。

```js
async function fn(args){
  // ...
}

// 等同于

function fn(args){ 
  return spawn(function*() { // spawn 函数就是自动执行器。
    // ...
  }); 
}
```

spawn 函数的实现：

```js
function spawn(genF) {
  return new Promise(function(resolve, reject) {
    var gen = genF();
    function step(nextF) { // 递归调用
      try {
        var next = nextF();
      } catch(e) {
        return reject(e); 
      }
      if(next.done) {
        return resolve(next.value);
      } 
      // The Promise.resolve(value) method returns a Promise object that is resolved with the given value.
      Promise.resolve(next.value).then(function(v) {
        step(function() { return gen.next(v); });      
      }, function(e) {
        step(function() { return gen.throw(e); });
      });
    }
    step(function() { return gen.next(undefined); });
  });
}
```

# PWA

原文链接：[下一代 Web 应用模型 —— Progressive Web App](https://huangxuan.me/2017/02/09/nextgen-web-pwa/)

## Web在移动端面临的问题

1. 客户端软件（即网页）需要下载所带来的网络延迟 -> 可能出现白屏。
2. Web 应用依赖浏览器作为入口所带来的体验问题。也就是，web 应用是浏览器这个应用中的应用，使用起来并不方便，而且加载也比原生应用要慢。

## 解决方案

1. Service Worker 与 Cache Storage：显著提高应用加载速度、甚至让 web 应用可以在离线环境使用。
2. Web App Manifest：用于描述 web 应用元数据（metadata）、让 web 应用能够**像原生应用一样被添加到主屏**、全屏执行。
3. Push API 与 Notification API：进一步提高 web 应用与操作系统集成能力，让 web 应用能在未被激活时发起推送通知。

结果：**无需担心网络延迟；有着独立入口与独立的保活机制。**

下面，我们来介绍部分解决方案：

## Web App Manifest

卧槽这个太厉害了，真的可以直接添加到桌面...赶紧自己启动个服务试试看！（好鸡冻，原谅我见识短～啊哈哈～）

实现的方法非常简单！

在 html 模版中引入：

```html
<link rel="manifest" href="./pwa/manifest.json">
```

写好配置文件 manifest.json：

```json
{ 
  "short_name": "Manifest Sample", 
  "name": "Web Application Manifest Sample", 
  "icons": [{ "src": "launcher-icon-2x.png", "sizes": "96x96", "type": "image/png" }], 
  "scope": "/", 
  "start_url": "../blockChain", 
  "display": "standalone", 
  "orientation": "landscape",
  "theme_color": "#000", 
  "background_color": "#fff"
}
```

字段说明：

* scope：定义了 web 应用的浏览作用域，比如作用域外的 URL 就会打开浏览器而不会在当前 PWA 里继续浏览。
* start_url：定义了一个 PWA 的入口页面。比如说你添加 Hux Blog 的任何一个文章到主屏，从主屏打开时都会访问 Hux Blog 的主页。
* orientation：终于，我们可以锁定屏幕旋转了🎉。
* theme_color/background_color：主题色与背景色，用于配置一些可定制的操作系统 UI 以提高用户体验，比如 Android 的状态栏、任务栏等。

就成了啊！厉害了简直🤩

## Service Worker

**目的：让 web 应用离线执行。**

其实，Service Worker 就是一个可编程的 Web Worker，它像一个位于浏览器与网络之间的**客户端代理**，可以拦截、处理、响应流经的 HTTP 请求；配合随之引入 Cache Storage API，你可以自由管理 HTTP 请求文件粒度的缓存，这使得 Service Worker 可以从缓存中向 web 应用提供资源，即使是在离线的环境下。

比如说，我们可以给网页 foo.html 注册这么一个 Service Worker，它将劫持由 foo.html 发起的一切 HTTP 请求，并统统返回未设置 Content-Type 的 Hello World!：

```js
// sw.js
self.onfetch = (e) => {
  e.respondWith(new Response('Hello World!'))
}
```

关于这部分，完整的代码可以见我的 Github/NodeCode：[pwa 入口](https://github.com/EmilyQiRabbit/NodeCode/blob/master/BlockChainInNode/views/PWAFirstTaste.ejs) 以及 [pwa 相关](https://github.com/EmilyQiRabbit/NodeCode/tree/master/BlockChainInNode/public/pwa)

在浏览器的调试方法是，打开开发者工具后，选择 Application，就可以在边栏看到 Server Worker，以及下面的 Cache。

感兴趣的话，可以自己跑跑项目试一试。

## Push Notification

...已晕...

## 总结

「我们相信 Web，是因为相信它是解决设备差异化的终极方案；我们相信，当 Web 在今天做不到一件事的时候，是因为它还没来得及去实现，而不是因为他做不到。而 Phonegap，它的终极目的就是消失在 Web 标准的背后。」

在不丢失 web 的开放灵魂，在不需要依靠 Hybrid 把应用放在 App Store 的前提下，让 web 应用能够渐进式地跳脱出浏览器的标签，变成用户眼中的 App。这是 Alex Russell 在 2015 年提出 PWA 概念的原委。

# 关系型数据库与非关系型数据库

## 关系型数据库

关系型数据库，是指采用了**关系模型**来组织数据的数据库。关系模型指的就是**二维表格模型**，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。

关系型数据库的两个优势：事务一致性、读写实时性。然而这两点，在现代 web 中，其实并没有那么重要。

**关系型数据库瓶颈**

1. 高并发读写需求：网站的用户并发性非常高，往往达到每秒上万次读写请求，对于传统关系型数据库来说，硬盘 I/O 是一个很大的瓶颈
2. 海量数据的高效率读写：网站每天产生的数据量是巨大的，对于关系型数据库来说，在一张包含海量数据的表中查询，效率是非常低的
3. 高扩展性和可用性：在基于web的结构当中，数据库是最难进行横向扩展的，当一个应用系统的用户量和访问量与日俱增的时候，数据库却没有办法像 web server 和 app server 那样简单的通过添加更多的硬件和服务节点来扩展性能和负载能力。对于很多需要提供24小时不间断服务的网站来说，对数据库系统进行升级和扩展是非常痛苦的事情，往往需要停机维护和数据迁移。

## 非关系型数据库

**分类**

1. 面向高性能**并发读写**的 key-value 数据库：key-value 数据库的主要特点即使具有极高的并发读写性能，**Redis, Tokyo Cabinet, Flare** 就是这类的代表。
2. 面向海量数据访问的面向文档数据库：这类数据库的特点是，可以在海量的数据中**快速的查询**数据，典型代表为 MongoDB 以及 CouchDB。（*文档型数据库可以看作是键值数据库的升级版，一般用类似 json 的格式存储。*）
3. 其他还有，图形数据库、列存储（Column-oriented）数据库等等。

# 一个按需加载的解决方案

解决方案：Intersection Observer API

Demo 可见 👉 test.html

官方文档 👉 [戳这里](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)

# 观察者模式

观察者模式也叫：发布者-订阅者模式。即，发布者发布事件，订阅者监听事件并做出反应。它可以用于 React 兄弟组件通讯。

栗子：

```js
import eventProxy from '../eventProxy'

class Parent extends Component{
  render() {
    return (
      <div>
        <Child_1/>
        <Child_2/>
      </div>
    );
  }
}
// componentDidUpdate 与 render 方法与上例一致
class Child_1 extends Component{
  componentDidMount() {
    setTimeout(() => {
      // 发布 msg 事件
      eventProxy.trigger('msg', 'end');
    }, 1000);
  }
}
// componentDidUpdate 方法与上例一致
class Child_2 extends Component{
  state = {
    msg: 'start'
  };

  componentDidMount() {
  	// 监听 msg 事件
    eventProxy.on('msg', (msg) => {
      this.setState({
        msg
      });
    });
  }

  render() {
    return <div>
      <p>child_2 component: {this.state.msg}</p>
      <Child_2_1 />
    </div>
  }
}
```

eventProxy:

```js
// eventProxy.js
'use strict';
const eventProxy = {
  onObj: {},
  oneObj: {},
  on: function(key, fn) {
    if(this.onObj[key] === undefined) {
      this.onObj[key] = [];
    }

    this.onObj[key].push(fn);
  },
  one: function(key, fn) {
    if(this.oneObj[key] === undefined) {
      this.oneObj[key] = [];
    }

    this.oneObj[key].push(fn);
  },
  off: function(key) {
    this.onObj[key] = [];
    this.oneObj[key] = [];
  },
  trigger: function() {
    let key, args;
    if(arguments.length == 0) {
      return false;
    }
    key = arguments[0];
    args = [].concat(Array.prototype.slice.call(arguments, 1));

    if(this.onObj[key] !== undefined
      && this.onObj[key].length > 0) {
      for(let i in this.onObj[key]) {
        this.onObj[key][i].apply(null, args);
      }
    }
    if(this.oneObj[key] !== undefined
      && this.oneObj[key].length > 0) {
      for(let i in this.oneObj[key]) {
        this.oneObj[key][i].apply(null, args);
        this.oneObj[key][i] = undefined;
      }
      this.oneObj[key] = [];
    }
  }
};

export default eventProxy;
```

# 对象的解构赋值

栗子1:

```js
let { foo, bar } = { foo: "aaa", bar: "bbb" };
foo // "aaa"
bar // "bbb"
```

注意，实际上，对象的解构赋值是下面形式的简写：

```js
let { foo: foo, bar: bar } = { foo: "aaa", bar: "bbb" };
```

也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。

```js
let { foo: baz } = { foo: "aaa", bar: "bbb" };
baz // "aaa"
foo // error: foo is not defined
```

上面代码中，foo 是匹配的模式，baz 才是变量。真正被赋值的是变量 baz，而不是模式 foo。



